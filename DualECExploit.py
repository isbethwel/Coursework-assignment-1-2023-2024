from ecdsa import ellipticcurve
from ecdsa.numbertheory import inverse_mod
from ecdsa.ellipticcurve import Point

# Parameters from the unique JSON data
p = int("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", 16)
a = int("0", 16)
b = int("7", 16)

# Defining the curve
curve = ellipticcurve.CurveFp(p, a, b)

# Initializing points P and Q with values from JSON data
Px = int("2ccda06ec335d875dfe264dbe3033b8e313a01b4c03a626c77b906d9de4c6434", 16)
Py = int("498aff1f84a990a6e0833984246993c81706c328cf7ba13552478ffdfbc7de8d", 16)
P = Point(curve, Px, Py)

Qx = int("1b1a0751bbcb917ffd37037ff2dce4dab640d5decfdc82716e519fc7da5cb4b0", 16)
Qy = int("d6a38d3c83c6afda3f97552099f4cf0bb4c4a1ba98a6a2dda0b44009794c51f8", 16)
Q = Point(curve, Qx, Qy)

# Functions gP and gQ 
def gP(x):
    return (x * P).x()

def gQ(x):
    return t((x * Q).x())

# Truncating the least significant 16 bits
def t(x):
    return x >> 16

# Ensuring  P and Q are on the curve
assert curve.contains_point(Px, Py)
assert curve.contains_point(Qx, Qy)

# Implementing  Dual_EC_DRBG using the functions and parameters
def dual_ec_drbg(nonce, curve, P, Q, n=5):
    # Converting  nonce to an integer
    s = int(nonce, 16)

    # Listing  to hold the pseudorandom numbers
    random_numbers = []

    for _ in range(n):
        s = gP(s)  # Updating  the internal state
        output = gQ(s)  # Generating  pseudorandom number
        truncated_output = format(output, 'x')  # Format output
        random_numbers.append(truncated_output)  # Append to list

    return random_numbers

# Implementing  the backdoor exploitation function
def exploit_backdoor(intercepted, factor, curve, P, Q, n=3):
    # Converting  the backdoor factor and intercepted numbers to integers
    d = int(factor, 16)
    r1 = int(intercepted[0], 16)
    r2 = int(intercepted[1], 16)

    # Calculating  the internal state using the backdoor
    s = (r1 * inverse_mod(d, curve.p()) * Q).x()

    # Listing  to hold the predicted pseudorandom numbers
    predicted_numbers = []

    for _ in range(n):
        s = gP(s)  # Update the internal state
        output = gQ(s)  # Generate pseudorandom number
        truncated_output = format(output, 'x')  # Format output
        predicted_numbers.append(truncated_output)  # Append to list

    return predicted_numbers

# Using actual values from JSON data
nonce = "936b3851"
intercepted = ["b22cfc689e168a15a7da58531fcff67b0e593d64d4c7650a47430c4ad0d3", "cc0acdf3d302090387955a16927e9449aebefa94d4e83acd96292bb7c021"]
factor = "7cbd2fa7"

prng_output = dual_ec_drbg(nonce, curve, P, Q)
predicted_output = exploit_backdoor(intercepted, factor, curve, P, Q)

print("Pseudorandom numbers:", prng_output)
print("Predicted numbers:", predicted_output)
